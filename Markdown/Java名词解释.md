# Java

## 1. 名词解释

### 1.1 包： 

在Java中，包（Package）是一种组织代码的形式，它可以包含一组相关的类、接口和其他包。包可以提供一种逻辑上的分组，使得代码的管理和维护更加方便。有如下作用：

* 把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。
* 如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，==包可以避免名字冲突==。
* 包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。

Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。如下：

```java
包的格式为：
package pkg1[．pkg2[．pkg3…]];
```



### 1.2  不可变类及不可变对象：

1. 不可变类：不可变类是指类一旦创建后，**不能改变其成员变量的值**，如JDK内部类：String，Long，Math类等。
   * 优点：
     1. 有利于线程安全：某个线程修改不可变对象时，会生成新的对象。原有的对象不会发生改变，所以其他线程中的引用，所指向的对象，并没有改变。就不会出现因为一个线程，修改了对象的属性，其他线程功能出现异常。
     2. 效率，例如字符串常量池，字符串常量池可以将一些字符常量放在常量池中重复使用，避免每次都重新创建相同的对象、节省存储空间。但如果字符串是可变的，此时相同内容的String还指向常量池的同一个内存空间，当某个变量改变了该内存的值时，其他遍历的值也会发生改变。所以不符合常量池设计的初衷。
   * 缺点：资源开销，对象需要频繁的修改属性，则每一次修改都会新创建一个对象，产生大量的资源开销。
   * 创建不可变类的原则：
     1. **所有成员变量必须是private**
     2. **最好同时用final修饰(非必须)**
     3. **不提供能够修改原有对象状态的方法**：
        * 最常见的方式是不提供setter方法
        * 如果提供修改方法，需要新创建一个对象，并在新创建的对象上进行修改
     4. **通过构造器初始化所有成员变量，引用类型的成员变量必须进行深拷贝(deep copy)**
     5. **getter方法不能对外泄露this引用以及成员变量的引用**
     6. **最好不允许类被继承(非必须)**
2. 不可变对象：不可变类的实例，对象一旦被创建后，对象所有的状态及属性在其生命周期内不会发生任何变化。

### 1.3 异常：

1. **异常体系结构**：在Java中，所有的异常都有一个共同的祖先 ==Throwable==(可抛出)，Throwable 指定代码中可用异常传播机制通过Java应用程序传输的任何问题的共性。有两个重要的子类，异常和错误的区别是：**异常能被程序本身可以处理，错误是无法处理的**

   ![img](https://img-blog.csdnimg.cn/2019101117003396.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5MjI5NTY3,size_16,color_FFFFFF,t_70)

2. **Error(错误)**：是程序无法处理的错误，表示运行应用程序中较严重错误。类包括一些严重的程序不能处理的系统错误类，如内存溢出、虚拟机错误、栈溢出等。这类错误一般由硬件有关，与程序本身无关，通常由系统进行处理，程序本身无法捕获和处理。

3. **异常**：异常是在运行程序时产生的一种异常情况。是程序本身可以处理的异常。异常主要分为==运行时异常(RuntimeException)==和==检查型异常(是Exception的类和子类中除掉RuntimeException)==（也叫非运行时异常和编译异常）两大类。

   1. **运行时异常**：程序员不需要去手动的try-catch。当程序中出现运行时异常时，JVM会进行处理。一般由程序逻辑错误引起的，特点是Java编译器不会检查它，可以编译过。都是RuntimeException类及其子类，就是我们在开发中测试功能程序终止，控制台出现的异常。常见如下：

      ```java
      
      ArithmeticException——由于除数为0引起的异常；
      ArrayStoreException——由于数组存储空间不够引起的异常；
      ClassCastException—一当把一个对象归为某个类，但实际上此对象并不是由这个类 创建的，也不是其子类创建的，则会引起异常；
      IllegalMonitorStateException——监控器状态出错引起的异常；
      NegativeArraySizeException—一数组长度是负数，则产生异常；
      NullPointerException—一程序试图访问一个空的数组中的元素或访问空的对象中的 方法或变量时产生异常；
      OutofMemoryException——用new语句创建对象时，如系统无法为其分配内存空 间则产生异常；
      SecurityException——由于访问了不应访问的指针，使安全性出问题而引起异常；
      IndexOutOfBoundsExcention——由于数组下标越界或字符串访问越界引起异常；
      IOException——由于文件未找到、未打开或者I/O操作不能进行而引起异常；
      ClassNotFoundException——未找到指定名字的类或接口引起异常；
      CloneNotSupportedException——一程序中的一个对象引用Object类的clone方法，但
      此对象并没有连接Cloneable接口，从而引起异常；
      InterruptedException—一当一个线程处于等待状态时，另一个线程中断此线程，从 而引起异常，有关线程的内容，将在下一章讲述；
      NoSuchMethodException一所调用的方法未找到，引起异常；
      Illega1AccessExcePtion—一试图访问一个非public方法；
      StringIndexOutOfBoundsException——访问字符串序号越界，引起异常；
      ArrayIdexOutOfBoundsException—一访问数组元素下标越界，引起异常；
      NumberFormatException——字符的UTF代码数据格式有错引起异常；
      IllegalThreadException—一线程调用某个方法而所处状态不适当，引起异常；
      FileNotFoundException——未找到指定文件引起异常； EOFException——未完成输入操作即遇文件结束引起异常。
          
      ```

      

   2. **检查型异常（非运行时异常，编译异常，必检异常）**：是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。**通俗的话说就是在写代码时出现红线，需要try catch或者throws时出现的异常**。

   3. **必检异常**：编译器要求必须处置的异常，**除Exception中的RuntimeException及RuntimeException的子类以外，其他的Exception类及其子类**(例如：IOException和ClassNotFoundException)都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。

   4. **免检异常**：编译器不要求强制处理的异常：包括==RuntimeException及其子类和Error==。

   5. **链式异常**：把捕获到的异常包装成一个新的异常，然后在新的异常里添加对原始异常的使用，再把新的异常抛出，就像链式反应，一个接着另一个。这就叫做链式异常。有助于异常日志更清晰。

   6. **总结**：对于必检异常必须捕捉（try_catch, try-catch-finally）或者声明抛出（throw, throws）。

### 1.4 类之间的关系：

1. **继承**：继承是面向对象最显著的一个特性，类只能单继承。继承是从已有类（父类、父接口）中派生出新的类（子类、子接口），新的类能吸收已有类的数据属性和行为，并能扩展新的能力。在Java中此类关系通过关键字==extends==明确标识。在UML图中，一般用一个带空心箭头得实线表示：

   ![继承关系UML图](https://img-blog.csdnimg.cn/img_convert/314d085eb3eba50f29ff53623d8d37dd.png#pic_center)

2. **实现**：是类和接口之间最常见的关系。指的是一个类实现接口的功能（一个类可以实现多个接口，接口可以继承多个接口），在Java中此类关系通过关键字==implements==明确标识，在UML图中，一般用一个带空心箭头的虚线表示

   ![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/d20b50ab7b391ad9f30810886bce57d6.png#pic_center)

3. **依赖**：指一个类队另外一个类的依赖。这种关系是一种非常弱的、临时性的关系。依赖关系在Java中体现为 **局域变量、方法的形参，或者对静态方法的调用**。比如说Employee类中有一个方法叫做TakeMoney(Bank bank)这个方法，在这个方法的参数中用到了Bank这个类。那么这个时候可以说Employee类依赖了Bank这个类，如果Bank这个类发生了变化那么会对Employee这个类造成影响。在UML图中，一般用一条指向被依赖事物的虚线箭头表示。如某人要过河，需要借用一条船，此时人与船之间的关系就是依赖。

   ![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/d85be6d26eaa38dc92608d9db6de1e69.png#pic_center)

4. **关联**：关联关系是类与类之间的联接，它使一个类知道另一个类的 **属性和方法**。关联可以是双向的，也可以是单向的，它是依赖关系更强的一种关系。在Java中，关联关系一般表现为被关联类B以类属性的形式出现在关联类A中，也可能是关联类A引用了一个类型为关联类B的全局变量。在UML图中，一般用一条实线箭头指向被关联类来表示。如我和我的朋友之间的关系。

   ![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/0918ce902e6ba9b91be5dec4c2df41b8.png#pic_center)

5. **聚合**：聚合是一种特殊的关联关系，它是较强的一种关联关系，强调的是整体与部分之间的关系，从语法上是没办法区分的，只能从语义上区分。例如雁群和大雁的关系、学校和学生之间的关系。聚合的整体和部分之间在生命周期上没有什么必然的联系，部分对象可以在整体对象创建之前创建，也可以在整体对象销毁之后销毁。在UML图中：一般用带一个空心菱形（整体）的实线指向部分来表示。如大雁 和 雁群的关系

   ![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/e224e0dd45247bd71ddde991833bad27.png#pic_center)

6. **组合**：组合也是关联关系的一种特例，这种比聚合关系更强。**它强调了整体与部分的生命周期是一致的。**在组合关系中，整体与部分之间是不可分的，整体生命的结束意味着部分的生命周期结束。在UML图中，一般用带实心菱形（整体的一端）的实线指向部分来表示。 如大雁和大雁的翅膀的关系。

   ![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/0b556e8ae3aab35268723978429ee489.png#pic_center)

对于继承、实现这两种关系比较简单，他们体现的是一种类与类、或者类与接口间的纵向关系；其他的四者关系则体现的是类与类、或者类与接口间的引用、横向关系。**总的来说，这几种关系所表现的强弱程度依次为：组合>聚合>关联>依赖**。

### 1. 4 类的其他：

1. **抽象类**：如果一个类中没有包含足够的信息来描绘一个具体的对象(可能**带有抽象方法**)，这样的类就是抽象类。抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法，类名要加 ==abstract== 明确修饰，子类继承父类抽象类如带有抽象方法的话。子类要么实现抽象方法，要么声明自身为抽象类。

2. **抽象类规则总结**：

   1.  抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。

   2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。

   3. 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。

      ```java
      public abstract class Employee
      {
         private String name;
         private String address;
         private int number;
         
         public abstract double computePay();//抽象方法
         
         //其余代码
      };
      ```

   4. 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。

   5.  抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。

3. **类的合约**：

4. **类的封装**：封装将类的某些信息隐藏在类内部，不允许外部程序直接访问，只能通过该类提供的方法来实现对隐藏信息的操作和访问。

   * 优点：

     1. 良好的封装能够减少耦合。
     2. 类内部的结构可以自由修改。
     3.  可以对成员变量进行更精确的控制。
     4.  隐藏信息，实现细节。

   * 实现封装的步骤：

     1. 修改属性的可见性来限制对属性的访问，一般设为 ==private==。
     2. 为每个属性创建==一对赋值（setter）方法和取值（getter）==方法，一般设为 public，用于属性的读写。
     3. 在赋值和取值方法中，加入属性控制语句（对属性值的合法性进行判断）。

   * ```java
     public class Employee {
         private String name; // 姓名
         private int age; // 年龄
         private String phone; // 联系电话
         private String address; // 家庭住址
         public String getName() {
             return name;
         }
         public void setName(String name) { // settter
             this.name = name;
         }
         public int getAge() {
             return age;
         }
         public void setAge(int age) {
             // 对年龄进行限制
             if (age < 18 || age > 40) {
                 System.out.println("年龄必须在18到40之间！");
                 this.age = 20; // 默认年龄
             } else {
                 this.age = age;
             }
         }
         public String getPhone() { //getter
             return phone;
         }
         public void setPhone(String phone) {
             this.phone = phone;
         }
         public String getAddress() {
             return address;
         }
         public void setAddress(String address) {
             this.address = address;
         }
     };
     ```

5. **数据域封装**：为了避免对数据域的直接修改，应该时使用==Private==将数据域声明为私有的，这称为数据域的封装。通常会设置一个修改器（set方法）来给数据域设置新值，一个访问器（get方法）来获取数据域的值。

6. **构造方法链**：构造一个类的实例时， 将会调用沿着继承链的所有父类的构造方法。 当构造一个子类的对象时， 子类构造方法会在完成自己的任务之前， 首先调用它的父类的构造方法。 如果父类继承自其他类， 那么父类构造方法又会在完成自己的任务之前，调用它自己的父类的构造方法。 这个过程持续到沿着这个继承体系结构的最后一个构造方法被调用为止。

7. **动态绑定**：也叫后期绑定和运行时绑定。即为在运行时根据具体对象的类型进行绑定，除了由==private，final，static==所修饰的方法和构造方法外，JVM在运行期间决定由哪个对象调用的过程称为动态绑定。

   * **动态绑定的过程**：编译看左边，运行看右边。
     1. 虚拟机提取对象的实际类型的方法表；
     2. 虚拟机搜素方法签名
     3. 调用方法

8. **super关键字和this关键字**：

   1. **super关键字**: **当前对象的直接父类的引用**，由于子类不难继承父类的构造方法，因此，如皋要调用父类的构造方法，可以使用super关键字，super可以用来访问父类的构造方法、普通方法和属性。在子类调用==super()必须是在子类构造方法的第一行==，但如果是访问父类的属性和方法是不用位于第一行。

   2. **this关键字**：**当前对象的引用**。

      * **使用**：

        1. this能出现在实例方法和构造方法中。

        2. this的语法是"this."和”this()“

        3. this不能出现在静态方法中

        4. this大部分情况下是可以省略的

        5. this在区分局部变量和实例变量不能省略，如

           ```java
           public void setName(String name) {
               this.name = name;
           }
           ```

   3. **两者的异同**：

      - super(参数)：调用基类中的某一个构造函数（应该为构造函数中的第一条语句）
      - this(参数)：调用本类中另一种形成的构造函数（应该为构造函数中的第一条语句）
      - super:　它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参） this：它代表当前对象名（在程序中易产生二义性之处，应使用 this 来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用 this 来指明成员变量名）
      - 调用super()必须写在子类构造方法的第一行，否则编译不通过。每个子类构造方法的第一条语句，都是隐含地调用 super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。
      - super() 和 this() 类似,区别是，super() 从子类中调用父类的构造方法，this() 在同一类内调用其它方法。
      - super() 和 this() 均需放在构造方法内第一行。
      - 尽管可以用this调用一个构造器，但却不能调用两个。
      - this 和 super 不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有 super 语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。
      - this() 和 super() 都指的是对象，所以，均不可以在 static 环境中使用。包括：static 变量,static 方法，static 语句块。
      - 从本质上讲，this 是一个指向本对象的指针, 然而 super 是一个 Java 关键字。

9. **多态**：同一个行为具有多个不同形式或形态的能力，也就是同一个接口，使用不同的实例二执行不同的操作，编译看左边，运行看右边（多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法）。

   1. **多态的优点**：1、消除类型之间的耦合关系 2、可替换性 3、可扩充性 4、接口性 4、灵活性 5、简化性
   2. **三个必要条件**：
      * **继承**
      * **重写**：当子类对象调用重写的方法时，调用的是子类的方法，而不是父类中被重写的方法。要想调用父类中被重写的方法，则必须使用关键字 **super**。
      * **父类引用指向子类对象**：

10. **Java的重写和重载**

  1. **重写(Override)**：重写是子类对父类的允许访问的方法的实现过程进行重新编写，返回值和形参都不能改变。 **即签名不变，核心重写**。

     * 重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。

       重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，抛出 IOException 异常或者 IOException 的子类异常。

     * **重写规则**：

       1. 参数列表与被重写方法的参数列表必须完全相同
       2. 返回类型与被重写方法的类型可以不相同，但必须是父类返回值的派生类。
       3. 访问权限不能比父类中被重写的方法的访问权限低
       4. 父类的成员方法只能被它的子类重写。
       5. 声明为==final、static==的方法不能被重写，但是==static==的可以被再次声明
       6. 构造方法不能被重写

  2. **重载(Overload)**：重载是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。每个重载的方法都必须有一个独一无二的参数类型列表。

     * **重载规则**：
       1. 被重载的方法必须改变参数列表（个数或类型不一样）
       2. 被充值该的方法可以改变返回类型
       3. 被重载的方法可以改变访问修饰符
       4. 被重载的方法可以声明新的或更广的检查异常
       5. 方法能够在同一个类中或者在一个子类中被重载
       6. 无法以返回值类型作为重载函数的区分标准

  3. **总结**：方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。

     1. 方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。
     2. 方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)
     3. 方法重载是一个类的多态性表现，而方法重写是子类与父类的一种多态性表现。

11. **类的设计原则**：

   1. **内聚性**：类应该被描述为一个单一的实体，而所有的类操作应该在逻辑上相互配合，支持一个一致性的目的。例如：可以设计一个类用于学生，但不应该将学生类与教职工类放在同一个类中，因为学生和教职工是不同的实体。

   2. **一致性**：遵循标准Java程序设计风格和命名习惯，为类、数据域和方法选取具有信息的名字，**通常风格是将数据域的声明置于构造方法之前，将构造方法置于方法之前，而对于在多个类中执行相同工作的方法，应该用同一个名字**。

   3. **封装性**：一个类应该用==private==修饰符隐藏数据域，以免用户直接访问它，这使得类更易于维护，只有在希望数据可读的时候才提供==get==方法，希望数据可更新的情况下才提供==set==方法。

   4. **清晰性**：用户可以以不同组合、顺序、以及在各种环境中结合使用多个类，因此在设计一个类时，这个类不应该限制用户如何以及何时使用该类，方法应在不产生混淆的情况下直观定义，不应该声明一个来自其他数据域的数据域。如，birthDate 和age，age可以从birthDate中计算出来，所以此处不应该再声明一个age数据域

   5. **完整性**：类是为很多用户而设计的，为了能在一个广泛的应用中使用，一个类应该 **通过属性和方法提供多种方案以适应用户的不同需求**。

   6. 实例和静态

      依赖于类的具体实例的变量或方法，必须是一个实例变量或方法，如果一个变量被类的所有实例所共享，那就应该声明为静态的。

      应该总是使用类名来访问静态数据域和方法，以增强可读性并避免错误。

      不要从构造方法中传入参数来初始化静态数据域，最好用set方法改变静态数据域。

      7、继承与聚合

      继承与聚合之间的差异是is-a和has-a之间的关系。

      8、接口和抽象类

12. 

     

   ​     

### 1.5 其他关键字：

1. **包装类**：Java中的数据类型int, double等不是对象，无法通过向上转型获取到Object提供的方法，也无法参与转型，泛型，反射等过程。为了弥补这个缺陷，Java提供了包装类。Java为每种基础数据类型分别设计了对应的类，称之为==包装类==。

   

  | 序号 | 基本数据类型 |  包装类   |
  | :--: | :----------: | :-------: |
  |  1   |     byte     |   Byte    |
  |  2   |    short     |   Short   |
  |  3   |     int      |  Integer  |
  |  4   |     long     |   Long    |
  |  5   |     char     | Character |
  |  6   |    float     |   Float   |
  |  7   |    double    |  Double   |
  |  8   |   boolean    |  Boolean  |

2. **装箱**：基本数据类型转换为包装类的过程称为装箱。

3. **拆箱**：包装类变为基本数据的过程称为拆箱。

4. **instanceof运算符**：intanceof是Java中的二元运算符，左边是对象，右边是类；当对象是右边类或者子类创建对象时，返回**true**，否则返回 "false"。

   ```java
   //注意：左边必须是对象，不能是基础数据类型
   
   int b = 0 ;
   res = b instanceof Integer; // error,编译错误
   
   ```

5. **标记接口**：标记接口是没有任何方法和属性的接口，它仅仅表明它的类属于一个特定的类型，供其他代码来测试允许做一些事情。使用标记接口的唯一目的是使得可以用instanceof进行类型查询。总之一句话，标记接口就是用来判断某个类是否具有某个能力的。主要有**Serializable接口，Cloneable接口，RandomAccess接口等**。

6. **子接口**：子接口继承了父接口。JAVA中一个接口可同时继承多个接口，但必须满足继承所有接口中的常量和抽象方法。

### 1.6 正则表达式







