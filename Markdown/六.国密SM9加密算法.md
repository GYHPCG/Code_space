### 六.国密SM9加密算法

#### 一.概念

**SM**9是基于双线性对的标识密码算法，与SM2类似，包含四个部分：总则，数字签名算法，密钥交换协议以及密钥封装机制和公钥加密算法。 在这些算法中使用了==椭圆曲线上的双线性对(经典的Weil对、Tate对，也有Ate对、R-ate对)==这一个工具，不同于传统意义上的SM2算法，可以实现基于身份的密码体制，也就是公钥与用户的身份信息即标识相关，从而比传统意义上的公钥密码体制有许多优点，省去了==证书管理==等。安全性基于椭圆曲线双线性映射的性质，当椭圆曲线离散对数问题和扩域离散对数问题的求解难度相当时，可用椭圆曲线对构造出安全性和实现效率兼顾的基于标识的密码算法。

#### 二.加密流程

1. **大致流程如下**：

   ![image-20221226204049931](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20221226204049931.png)

2. **密钥生成**：

   1. SM9算法的密钥由==KGC==(密钥生成中心)产生，主要包括KGC的主密钥对和用户的私钥。 主密钥对分为**签名主密钥对**和**加密主密钥对**。

      - KGC产生随机数ke∈[1,N−1]作为加密主私钥，计算G1中的元素Ppub−e=[e]P1作为加密主公钥，KGC秘密保存ke，公开Ppub−e。**注意**：N 为循环群G1、G2和Gt的阶，大于==2^191的素数==

        KGC选择并公开用一个字节表示的加密私钥生成函数识别符hid。

        KGC根据用户B的IDB计算用户B的加密私钥deB。KGC首先在有限域FNFN上计算t1=H1(IDB∥hid,N)+ke，若t1=0则需重新产生加密主私钥，计算和公开加密主公钥，并更新已有用户的加密私钥;否则计算。否则计算t2=ke⋅t1−1，然后计算deB=[t2]P2。

   2. **签名主密钥对**：其私钥是一个在[1,N-1]范围内的随机数；公钥是G2群的基点P2的倍点，倍数为私钥。(**注意**：以下倍点具体求法同**SM2**)

   3. **加密主密钥对**：其私钥是一个在[1,N-1]范围内的随机数；公钥是G1群的基点P1的倍点，倍数为私钥。

   4. 主密钥对的公私钥用在不同场景，其中主私钥仅用于计算用户私钥；主公钥则由KGC公开并用在其他部分。同时，签名主公钥仅用于签名和验签算法；加密主公钥则用于密钥封装、加密和密钥交换,用户私钥由KGC产生，包括签名私钥和加密私钥。

   5. **签名私钥**：是G1群的基点P1的倍点。签名私钥仅用于签名中

      **加密私钥**：是G2群的基点P2的倍点。加密私钥用于密钥解封、解密和密钥交换中私钥KGC使用主私钥和用户身份标识(以下简称ID)生成用户的私钥。

3. **详细流程**：

   1. 设需要发送的消息为比特串M，mlen 为M的比特长度，K1_len为分组密码算法中密钥 K1 的比特长度，K2_len 为**消息认证码函数MAC(K2, Z)** 中密钥 K2 的比特长度，标识为 IDb（可以唯一确定用户B的公钥），识别符符 hid。

   2. 计算群 **G1**中的元素 **QB = [H1(IDb || hid，N)]P1 + Ppub-e**

      - H1()和H2()函数都是由密码杂凑函数Hv()派生的密码函数。其结果都是返回一个==1~ n -1==的整数，具体操作如下。

        ![image-20221228200646984](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20221228200646984.png)

        

      - **G1**：阶为素数N的加法循环群

   3. 产生随机数 **1 <= r <= N - 1**

   4. 计算群 **G1**中的元素 **C1=[r]QB**，将 **C1的数据类型转换为比特串**（该处C1的倍数点计算是定义在群上的，和普通代数计算不一样，具体可看上面 **四.国密SM2加密算法中公私钥的计算过程**）

   5. 计算群 **Gt** 中的元素 g = e(Ppub-e, P2)

      - **Gt**：阶为素数N的乘法循环群

   6. 计算群 **Gt** 中的元素 w = gr，将 W 的数据类型转换为比特串

      - ==gr==为乘法群Gt中元素g的r次幂

   7. 按加密明文的方法分类进行计算 （关于KDF函数的具体操作可看上文的**SM2加密**）

      - 如果加密明文的方法是基于密钥派生函数KDF的==序列密码==算法
        1. 计算整数**klen = K1_len + K2_len**，然后计算 **K=KDF(C1 || w || IDb，klen)**。令K1 为 K左边的K1_len 比特，K2为剩下的K2_len比特，若==K1为全0比特串==，则返回步骤**3**，重新开始计算。
        2. 否则就计算**C2 = M 异或 K1**。
      - 如果加密明文的方法是结合密钥派生函数KDF的==分组密码==算法
        1.  计算整数**klen = K1_len + K2_len**，然后计算 **K = KDF(C1 || w || IDb，klen)**。令K1 为 K左边的K1_len 比特，K2为剩下的K2_len比特，若==K1为全0比特串==，则返回步骤**3**，重新开始计算。
        2.  否则计算 **C2 = Enc(K1, M)**

   8. 计算 **C3 = MAC(K2，C2)**

      - 消息认证码函数MAC(K2,Z)的作用是防止消息数据Z被非法篡改，它在密钥K2的控制下，产生消息数据比特串Z的认证码。在本基于标识的加密算法中，消息认证码函数使用密钥派生函数生成的密钥对密文比特串求取消息认证码，从而使解密者可以鉴别消息的来源和检验数据的完整性。消息认证码函数需要调用密码杂凑函数。
      - **输入**：比特串K2(比特长度为K2_len的密钥)，比特串Z(待求取消息认证码的消息)
      - **输出**：长度为v的消息认证码数据比特串K, k = Hv(Z||K2)

   9. 输出密文 **C = C1 || C3 || C2**。

